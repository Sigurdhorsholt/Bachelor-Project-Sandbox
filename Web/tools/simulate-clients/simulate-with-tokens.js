/*
  simulate-with-tokens.js

  Usage (PowerShell):
    $env:SIGNALR_URL = 'http://localhost:5076/hub/meetings'
    $env:TOKENS_FILE = './tokens.json'    # generated by fetch-tokens.ps1
    $env:MEETING_CODE = 'FD2MJH'
    node simulate-with-tokens.js

  Environment variables (defaults):
    SIGNALR_URL  - default: http://localhost:5076/hub/meetings
    TOKENS_FILE  - default: ./tokens.json (array of token strings)
    MEETING_CODE - default: FD2MJH
    CLIENT_COUNT - default: use all tokens in tokens.json
    START_DELAY_MS - default 200 ms between client connects
*/

// Allow skipping Node's TLS certificate validation for local development when requested via env var
if (process.env.SKIP_NODE_TLS === '1' || process.env.SKIP_NODE_TLS_REJECT_UNAUTHORIZED === '1') {
  // Note: this disables TLS verification for the entire Node process. Only use for local development.
  process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
  console.warn('WARNING: NODE_TLS_REJECT_UNAUTHORIZED=0 (skipping TLS cert validation)');
}

const { HubConnectionBuilder, LogLevel, HttpTransportType } = require('@microsoft/signalr');
const fs = require('fs');
const path = require('path');

const SIGNALR_URL = process.env.SIGNALR_URL || 'http://localhost:5076/hub/meetings';
const TOKENS_FILE = process.env.TOKENS_FILE || path.join(__dirname, 'tokens.json');
const MEETING_CODE = process.env.MEETING_CODE || 'FD2MJH';
const CLIENT_COUNT = process.env.CLIENT_COUNT ? parseInt(process.env.CLIENT_COUNT, 10) : undefined;
const START_DELAY_MS = process.env.START_DELAY_MS ? parseInt(process.env.START_DELAY_MS, 10) : 200;
const SIGNALR_TRANSPORT = (process.env.SIGNALR_TRANSPORT || 'Auto').toLowerCase();

function loadTokens(filePath) {
  if (!fs.existsSync(filePath)) {
    throw new Error(`Tokens file not found: ${filePath}`);
  }
  let raw = fs.readFileSync(filePath, 'utf8');
  // Strip UTF-8 BOM if present and trim leading whitespace
  raw = raw.replace(/^\uFEFF/, '').trimStart();
  try {
    const arr = JSON.parse(raw);
    if (!Array.isArray(arr)) throw new Error('Tokens file must be a JSON array of token strings');
    return arr;
  } catch (err) {
    throw new Error(`Failed to parse tokens file ${filePath}: ${err.message}`);
  }
}

function parseJwtPayload(token) {
  try {
    const parts = token.split('.');
    if (parts.length < 2) return null;
    let payload = parts[1];
    // Fix base64 padding
    payload = payload.replace(/-/g, '+').replace(/_/g, '/');
    while (payload.length % 4) payload += '=';
    const json = Buffer.from(payload, 'base64').toString('utf8');
    return JSON.parse(json);
  } catch (err) {
    return null;
  }
}

async function tryStartConnection(connection, i) {
  try {
    await connection.start();
    return true;
  } catch (err) {
    console.warn(`Client ${i} initial start failed:`, err && err.message ? err.message : err);
    // If negotiation failed (fetch failed), attempt a fallback: skip negotiation and use WebSockets directly
    const msg = (err && err.message) ? err.message.toLowerCase() : '';
    if (msg.includes('negotiate') || msg.includes('fetch failed')) {
      console.log(`Client ${i} attempting fallback: skipNegotiation + WebSockets`);
      try {
        const conn2 = new HubConnectionBuilder()
          .withUrl(SIGNALR_URL, { accessTokenFactory: connection._options && connection._options.accessTokenFactory ? connection._options.accessTokenFactory : () => null, skipNegotiation: true, transport: HttpTransportType.WebSockets })
          .configureLogging(LogLevel.Warning)
          .build();
        // wire basic handlers similar to original connection
        conn2.onclose(err => console.warn(`Client ${i} closed (fallback):`, err && err.message));
        conn2.on('TickAck', (payload) => console.log(`Client ${i} TickAck:`, JSON.stringify(payload)));
        conn2.on('Connected', (info) => console.log(`Client ${i} server Connected (fallback):`, info));
        conn2.on('connected', (info) => console.log(`Client ${i} server connected (fallback, lowercase):`, info));
        conn2.on('ShowConnectedIndicator', (show) => console.log(`Client ${i} ShowConnectedIndicator (fallback):`, show));
        conn2.on('showConnectedIndicator', (show) => console.log(`Client ${i} showConnectedIndicator (fallback, lowercase):`, show));
        conn2.on('ParticipantJoined', (dto) => console.log(`Client ${i} ParticipantJoined (fallback):`, JSON.stringify(dto)));
        conn2.on('participantJoined', (dto) => console.log(`Client ${i} participantJoined (fallback, lowercase):`, JSON.stringify(dto)));
        conn2.on('ParticipantLeft', (dto) => console.log(`Client ${i} ParticipantLeft (fallback):`, JSON.stringify(dto)));
        conn2.on('participantLeft', (dto) => console.log(`Client ${i} participantLeft (fallback, lowercase):`, JSON.stringify(dto)));
        await conn2.start();
        console.log(`Client ${i} connected via fallback (id=${conn2.connectionId}).`);
        return conn2; // return the new connection object to caller
      } catch (err2) {
        console.error(`Client ${i} fallback connection failed:`, err2 && err2.message ? err2.message : err2);
        return false;
      }
    }
    return false;
  }
}

function transportOptionForBuilder() {
  // returns an options object to pass to withUrl
  if (SIGNALR_TRANSPORT === 'websockets') {
    return { skipNegotiation: true, transport: HttpTransportType.WebSockets };
  }
  if (SIGNALR_TRANSPORT === 'serversentevents' || SIGNALR_TRANSPORT === 'serversentevent') {
    return { transport: HttpTransportType.ServerSentEvents };
  }
  if (SIGNALR_TRANSPORT === 'longpolling' || SIGNALR_TRANSPORT === 'long-polling') {
    return { transport: HttpTransportType.LongPolling };
  }
  // Auto/default: no explicit transport option (let the client negotiate)
  return {};
}

async function createClient(i, token) {
  const transportOpts = transportOptionForBuilder();
  const connection = new HubConnectionBuilder()
    .withUrl(SIGNALR_URL, Object.assign({ accessTokenFactory: () => token }, transportOpts))
    .configureLogging(LogLevel.Warning)
    .build();

  connection.onclose(err => console.warn(`Client ${i} closed:`, err && err.message));

  connection.on('TickAck', (payload) => {
    console.log(`Client ${i} TickAck:`, JSON.stringify(payload));
  });

  // server-invoked helpers for visibility
  connection.on('Connected', (info) => {
    console.log(`Client ${i} server Connected:`, info);
  });
  // also accept lowercase for servers that send camelCase method names
  connection.on('connected', (info) => {
    console.log(`Client ${i} server connected (lowercase):`, info);
  });

  connection.on('ShowConnectedIndicator', (show) => {
    console.log(`Client ${i} ShowConnectedIndicator:`, show);
  });
  connection.on('showConnectedIndicator', (show) => {
    console.log(`Client ${i} showConnectedIndicator (lowercase):`, show);
  });

  connection.on('ParticipantJoined', (dto) => {
    console.log(`Client ${i} ParticipantJoined:`, JSON.stringify(dto));
  });
  connection.on('participantJoined', (dto) => {
    console.log(`Client ${i} participantJoined (lowercase):`, JSON.stringify(dto));
  });

  connection.on('ParticipantLeft', (dto) => {
    console.log(`Client ${i} ParticipantLeft:`, JSON.stringify(dto));
  });
  connection.on('participantLeft', (dto) => {
    console.log(`Client ${i} participantLeft (lowercase):`, JSON.stringify(dto));
  });

  try {
    const startResult = await tryStartConnection(connection, i);
    if (startResult === true) {
      console.log(`Client ${i} connected (id=${connection.connectionId}).`);
    } else if (startResult && typeof startResult === 'object') {
      // fallback returned a connection instance
      // replace the connection variable's properties by returning the fallback
      console.log(`Client ${i} using fallback connection object.`);
      // startResult is the fallback connection; continue with that
      // tryStartConnection already logged the connection; use it for further actions
      const conn2 = startResult;
      // try to derive meetingId from token payload
      let meetingIdToJoin = MEETING_CODE;
      const payload = parseJwtPayload(token);
      if (payload && payload.meetingId) {
        meetingIdToJoin = payload.meetingId;
        console.log(`Client ${i} derived meetingId from token: ${meetingIdToJoin}`);
      } else {
        console.log(`Client ${i} could not derive meetingId from token, falling back to meeting code: ${MEETING_CODE}`);
      }

      try {
        await conn2.invoke('JoinMeeting', meetingIdToJoin);
        console.log(`Client ${i} joined meeting ${meetingIdToJoin}`);
      } catch (err) {
        console.warn(`Client ${i} failed to join meeting:`, err && err.message ? err.message : err);
      }

      return conn2;
    } else {
      throw new Error('Connection start failed');
    }

    // try to derive meetingId from token payload
    let meetingIdToJoin = MEETING_CODE;
    const payload = parseJwtPayload(token);
    if (payload && payload.meetingId) {
      meetingIdToJoin = payload.meetingId;
      console.log(`Client ${i} derived meetingId from token: ${meetingIdToJoin}`);
    } else {
      console.log(`Client ${i} could not derive meetingId from token, falling back to meeting code: ${MEETING_CODE}`);
    }

    // Ask server side to add connection to meeting group
    try {
      await connection.invoke('JoinMeeting', meetingIdToJoin);
      console.log(`Client ${i} joined meeting ${meetingIdToJoin}`);
    } catch (err) {
      console.warn(`Client ${i} failed to join meeting:`, err && err.message ? err.message : err);
    }
  } catch (err) {
    console.error(`Client ${i} failed to connect:`, err && err.message ? err.message : err);
  }

  return connection;
}

(async () => {
  console.log(`Simulator (with tokens) starting: url=${SIGNALR_URL} tokensFile=${TOKENS_FILE} meeting=${MEETING_CODE}`);
  let tokens;
  try {
    tokens = loadTokens(TOKENS_FILE);
  } catch (err) {
    console.error(err.message);
    process.exit(1);
  }

  const count = CLIENT_COUNT ? Math.min(CLIENT_COUNT, tokens.length) : tokens.length;
  console.log(`Found ${tokens.length} tokens, starting ${count} clients (delay ${START_DELAY_MS}ms)`);

  const clients = [];
  for (let i = 0; i < count; i++) {
    // create sequentially with small delay so server logs are readable
    // eslint-disable-next-line no-await-in-loop
    const c = await createClient(i + 1, tokens[i]);
    clients.push(c);
    // eslint-disable-next-line no-await-in-loop
    await new Promise(r => setTimeout(r, START_DELAY_MS));
  }

  console.log(`${clients.length} clients created. Press Ctrl+C to exit.`);
  process.stdin.resume();
})();
